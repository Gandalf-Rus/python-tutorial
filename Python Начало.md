# Ввод/Вывод в консоль

* `ptint("текст")` - писать в консоль (выводит)
	* `ptint(a, b, ...)` - перечисление через запятую
* `input()` - для получения **СТРОКИ** из консоли.
	* Ждет ввода с консоли
* Переменная  - коробка, в которую можно что-то положить и что-то посмотреть. У каждой переменной (коробки) есть имя.
	* То что слева  коробка куда кладем, то что справа вещь что будет лежать в коробке.

# Данные. Виды данных

Данные:
* Числа (integer)
* Числа с плавающей точкой (float) 
* Текст (string)
* Булевое значение, Правда/ложь (bool)

```py
a = 5     # целые числа
b = 1.25  # вешественные числа (с точкой)
c = "abc" # текст
d = True  # булевое значение (True/False)
```

# Арифметические операции

* Такие как `+, -, *, /, %, //, **` и `( )`, они работают также как в обычной математике
	* `+` - сложение
	* `-` - вычитание
	* `*` - умножение
	* `/` - деление
	* `%` - остаток от деления
	* `//` - целочисленное деление
	* `**` - возведение в степень
* Результаты можно сохранять в переменные.
*  `int("1")` - делает строки числами если это возможно.
	* `int(input())` - сделать строку из ввода сразу числом. Сначала выполняется input потом int.

# Сравнение

* Знаки сравнения:
	* `==` - равно
	* `!=` - не равно
	* `<` - меньше
	* `<=` - меньше или равно
	* `>` - больше
	* `>=` - больше или равно
* Знаки сравнения нужны для сравнения :)
* Результат сравнений - булевое значение (True/False)
* Примеры:
```py
5 == 5     # True
3 > 4      # False
"a" == "a" # True

a = 1
a >= 0     # True

213 <= 213 # True
11 != 11   # False

```


# Условные конструкции

* `if` (если)  - для проверки условия
* После `if` пишется условие - которое True (правда) или False (неправда) 
* Под `if`, на следующей строке через 4 пробела (или таб) пишется действие если условие верно
* Таб - тогда

```py
if условие:
	действие
```
* Условия можно делать составными с помощью `and` и `or`
* Примеры:
```py
a = 2
b = 1
if a >= b and a < 10: # (True and True) == True
	print("a больше b и меньше 10") # успешно напишется т к условие выполнилось

if a == 0 or b > 0: # первое неверно второе верно (False or True) == True
	print("a == 0 или b больше 0")
```
* Если в `if` оказалось неверное условие (False), то действие под ним не выполниться (те что с табом)

* Если ни одно условие не выполнилось то можно прописать `else`
* `else` (иначе) - выполняется если прошлые условия (`if` и `elif`) неправильны.

* Если в `if` неверное условие (False), но надо проверить другое условие используй `elif` 
* `elif` (иначе если) - для проверки  условия после неудачной проверки `if`-условия
* `elif`-ов можно прописывать сколько угодно, они будут выполняться если не выполнились предыдущие условия
```py
if условие1:
	действие1
elif условие2:
	действие2
elif условие3:
	действие3
elif условие4:
	действие4
...
else:
	действие если все условия не верны
```

# Циклы

> [!INFO]
> * **Циклы** - конструкция (штука) для повторения каких-то действий несколько раз 




## Цикл **while**

* Представь что нужно поколоть орехи.
	* Ты берешь 1-ой орех, берешь молоток, колешь
	* Берешь 2-ой орех, берешь молоток, колешь
	* И делаешь так пока есть орехи
	* В программе мы бы писали для каждого ореха эти действия
* Вот как бы выглядел код для 6 орехов без цикла:

```py
print("Беру орех №1")
print("Беру молоток")
print("Колю орех")

print("Беру орех №2")
print("Беру молоток")
print("Колю орех")

print("Беру орех №3")
print("Беру молоток")
print("Колю орех")

print("Беру орех №4")
print("Беру молоток")
print("Колю орех")

print("Беру орех №5")
print("Беру молоток")
print("Колю орех")

print("Беру орех №6")
print("Беру молоток")
print("Колю орех")
```

* Согласись тут что-то не то
* А что если орехов было бы не *6* или надо было бы их помыть? Пришлось бы все переписывать, и можно допустить ошибку при копировании кода 
* на помощь приходит **while**

> [!INFO]
>  *while* - выполняет действия пока условие верно
> ```py
> while условие:
> 	делай что-то
> 	и еще что-то
> 	и так далее...
> ```
> 

* Вот как бы выглядел код для 6 орехов c циклом while:
```py
nuts = 6
current_nut = 1

while nuts > 0:
	print("Беру орех", current_nut)
	print("Беру молоток")
	print("Колю орех")
	nuts -= 1        # отнять 1
	current_nut += 1 # прибавить 1
  
```

* Код вышел меньше, читабельнее и надежнее. 
* Если орехов будет больше то нужно изменить всего 1 переменную, в случае с действием просто дописать действие, вместо правки всей программы


* Вот еще пример:
```py
a = int(input())  # считываем число  
while a > 0:  # проверяем условие, если оно верно то делаем что-то  
    print(a, "больше нуля")  # действие  
    a = int(input())  # считываем в а, и идем на проверку условия (2 строка)
```

* Наглядная схема работы **while**:

![[Drawing 2024-11-08 11.56.47.excalidraw]]

> Теорию рассказали, но без практики она ни к чему, иди решай задачи


## Цикл **for**

* Вспомним про орехи:
	* Представим что нужно поколоть 10 орехов
* без цикла было бы:

```py
print("Беру орех №1")
print("Беру молоток")
print("Колю орех")

print("Беру орех №2")
print("Беру молоток")
print("Колю орех")

# --- 
# и так далее
# --

print("Беру орех №10")
print("Беру молоток")
print("Колю орех")
```

* С циклом while было бы удобнее:

```py
nuts = 10  
current_nut = 1  # счетчик  
  
while nuts > 0:  
    print("Беру орех", current_nut)  
    print("Беру молоток")  
    print("Колю орех")  
    nuts -= 1  
    current_nut += 1

```

* Вроде удобно, но можно ли еще удобнее, не писать лишних переменных и счетчиков? Можно! На помощь приходит цикл **for**

> [!INFO]
> *for* - повторяет действия в числовом промежутке с заданным шагом
> ```py
> for i in range(начало, конец, шаг): 
> 	делай что-то
> 	и еще что-то 
> 	и так далее...
> ```
> * **начало** - начало диапазона (начало отсчета)
> * **конец** - конец диапазона (конец отсчета)
> * **шаг** - число, на которое увеличивается **i** каждое повторение цикла
> * **i** - счетчик

* Вот как выглядел бы наш код с орехами если использовать for:

```py
for i in range(1, 10):
	print("Беру орех", i)
	print("Беру молоток")
	print("Колю орех")
```

* Наглядная схема работы **for**:
![[Drawing 2024-11-23 15.23.43.excalidraw]]


## break, continue

> [!summary]
> **break** - для выхода из цикла
> **continue** - для перехода к следующему шагу цикла


---
<br>

# **Коллекции**


> [!INFO]
> **Коллекции** - тип данных, в котором можно хранить не одно значение.

## *Общие свойства коллекций*

> [!Info]
> * Длина *len* - количество элементов\* в коллекции
> 
> \*элемент - какое-то значение (вещь)


---
<br>

## Списки (list)


> [!INFO]
> **Список** — это упорядоченная изменяемая коллекция, которая может содержать элементы\* любого типа
> 
> или проще говоря
> 
> **Список** — *это коробка, в которой можно хранить любые вещи в определённом порядке. Можно менять порядок вещей, брать добавлять, и убирать их из этой большой коробки*
> 
> \*элемент - какое-то значение (вещь)



![[Drawing 2025-01-16 14.56.26.excalidraw]]

<br>

### Создание списка

```py

my_list1 = list()                        # list в переводе с англ. "список"
my_list2 = []                            # или просто квадратные скобки
my_list3 = [1, 2, "hello", 3, True, 4.1] # так можно создать заполненный список

```
<br>

### Длина

>[!tip]
>Как и у всех коллекций у списка есть длинна **len** (*от сокращенного англ. lenght - длина*)
> узнать длину довольно просто:
> ```py
> a = [1, 2, 3]      # какой-то список
> len(a)             # выдаст длину, в этом случае 3
> list_len = len(a)  # ее можно записать в переменную
> print(len(a))      # или сразу использовать как число
> ```

<br>

### Индексы

> [!INFO]
> **Индекс** - это порядковый номер элемента\* в списке. Индексация начинается с **0** 
> *(Индекс - номерок под которым лежит элемент, отсчет элементов в списке начинается с 0)*
> 
> \*элемент - какое-то значение (*вещь*)

* Предположим что у нас есть список `["a", "b", "c", "d", "e"]`
* Под индексом **0** лежит `"a"`
* Под индексом **1** лежит `"b"`
* И так далее...
* Последний элемент лежит под индексом **4**
<br>

### Взятие элемента

> [!INFO]
> Взять элемент из списка можно по его индексу (порядковому номеру), написав `список[индекс]`

* Пример: 

```py
my_list = ["a", "b", "c", "d", "e"]
print(my_list[0]) # => a
print(my_list[1]) # => b
# ...
print(my_list[4]) # => e
print(my_list[5]) # => ошибка, нет элемента под этим индексом
```

> [!WARNING]
> * **Важно**, если пробовать взять элемент по `индекс >= len(список)` то будет **ошибка**. Почему:
> 	* `len(список)` возвращает длину списка (в данном случае *5*)
> 	* Последний элемент в этом списке лежит под индексом **4**
> 	* если попытаться взять элемент по несуществующему индексу то будет **ошибка**
<br>

### Перезапись элемента

> [!INFO]
> Перезаписать элемент в список можно по индексу (существующему)
> `список[индекс] = новый_элемент`


* Пример: 

```py
my_list = ["a", "b", "c", "d", "e"]

print(my_list)     # => ["a", "b", "c", "d", "e"]
my_list[0] = "one" # теперь вместо "a" записано "one"
print(my_list)     # => ["one", "b", "c", "d", "e"]

my_list[5] = "six" # ошибка

```

> [!WARNING]
> * **Важно**, если пробовать перезаписать элемент по `индекс >= len(список)` то будет **ошибка**. Почему:
> 	* `len(список)` возвращает длину списка (в данном случае *5*)
> 	* Последний элемент в этом списке лежит под индексом **4**
> 	* если попытаться взять элемент по несуществующему индексу то будет **ошибка**


---
### Добавление элемента (в конец)

> [!INFO]
> Добавить элемент в конец списка можно командой `.append(элемент)`
> `список.append(новый элемент)`

* Пример: 

```py
my_list = ["a", "b", "c", "d", "e"]

print(my_list)     # => ["a", "b", "c", "d", "e"]
my_list.append("f")
print(my_list)     # => ["a", "b", "c", "d", "e", "f"]
```

### Добавление элемента (в любое место)

> [!INFO]
> Добавить элемент в список в любом месте можно командой `.insert(индекс, элемент)`
> `список.insert(индекс, новый элемент)
* **Как это работает?**
	* ставиться элемент по индексу и все остальные элементы после этого индекса сдвигаются вправо на 1. 
* Пример: 

```py
my_list = ["a", "b", "c", "d", "e"]

print(my_list)     # => ["a", "b", "c", "d", "e"]
my_list.insert(1, "1")
print(my_list)     # => ["a", "1", "b", "c", "d", "e", "f"]
```

> [!WARNING]
> * Стоит помнить, что добавление в конец списка предпочтительней, т. к. *легче для компьютера*

### Списки + циклы

> [!Tip]
> Для перебора/заполнения/получения (и много чего еще)  всех значений списка часто используют циклы:
> ```py
> for i in range(len(список)):
> 	print(список[i]) # печать всех элементов списка
> ```

* Пример: 

```py
my_list = ["a", "b", "c", "d", "e"]

for i in range(len(my_list)):
	print(my_list[i])
```

